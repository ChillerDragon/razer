******************************************
*  Razer device configuration tool       *
* Copyright (c) 2007-2009 Michael Buesch *
******************************************

This is a configuration utility for Razer devices on Linux systems.


DEPENDENCIES
============

 * python
   http://www.python.org/

 * libusb
   http://libusb.sourceforge.net/

 * QT4 (for the graphical qrazercfg tool only)
   http://www.trollech.com/

 * cmake (for building only)
   http://www.cmake.org/

Note that almost all distributions ship prebuilt packages of the
above dependencies.


BUILDING
========

First invoke "cmake" to build the makefiles.
Then invoke "make" to build the binaries.

  cmake .
  make

(Note the required space and dot after the cmake command)


INSTALLING
==========

  make install


USING THE TOOLS
===============

To use the tools, the "razerd" daemon needs to be started as root, first.
Without the background daemon, nothing will work. The daemon is responsible
for doing the lowlevel hardware accesses and for tracking the current state
of the device.
While the daemon is running, the user interfaces "razercfg" (commandline) and
"qrazercfg" (graphical user interface) can be used.


UDEV NOTIFICATION
=================

The file "01-razer-udev.rules" in this package contains example rules
on how to handle automatic device connect notification through udev.
On Debian/Ubuntu Linux you need to
   cp 01-razer-udev.rules /etc/udev/rules.d/01-razer.rules
to install the rules. Note that you might have to adjust the RUN path in
the .rules file, if you didn't install the stuff to /usr/local.


ARCHITECTURE
============

The architecture layout of the razer tools looks like this:


 -------------------
| hardware driver 0 |--v
 -------------------   |
                       |    ----------
 -------------------   |   | lowlevel |     --------      ---------
| hardware driver 1 |--x---| librazer |----| razerd |----| pyrazer |
 -------------------   |    ----------      --------      ---------
                       |                        |           ^ ^ ^
 -------------------   |                   -----------      | | |
| hardware driver n |--^                  | librazerd |     | | |
 -------------------                       -----------      | | |
                                              ^ ^ ^         | | |
                                              | | |         | | |
                           ---------------    | | |         | | |
                          | Application 0 |---^ | |         | | |
                           ---------------      | |         | | |
                                                | |         | | |
                           ---------------      | |         | | |
                          | Application 1 |-----^ |         | | |
                           ---------------        |         | | |
                                                  |         | | |
                           ---------------        |         | | |
                          | Application n |-------^         | | |
                           ---------------                  | | |
                                                            | | |
                           ----------                       | | |
                          | razercfg |----------------------^ | |
                           ----------                         | |
                                                              | |
                           -----------                        | |
                          | qrazercfg |-----------------------^ |
                           -----------                          |
                                                                |
                            --------------------------          |
                          | Other Python applications |---------^
                           ---------------------------

So in general, your application wants to access the razer devices through
pyrazer or (if it's not a python app) through librazerd.
(Note that librazerd is not written, yet. So currently the only way to
access the devices is through pyrazer).
Applications should never poke with lowlevel librazer directly, because there
will be no instance that keeps track of the device state and permissions and
concurrency.
